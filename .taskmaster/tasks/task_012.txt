# Task ID: 12
# Title: Implement Zoom and Pan Navigation with Orientation Cues
# Status: pending
# Dependencies: 2
# Priority: medium
# Description: Add subtle grid/guide backgrounds to help with orientation during zoom and pan navigation.
# Details:
Implement zoom and pan navigation features:
- Add a subtle grid background that scales appropriately with zoom level
- Implement smooth zoom in/out functionality with mouse wheel and buttons
- Create intuitive pan navigation when dragging the background
- Add a mini-map or navigator in a corner for orientation in large charts
- Include visual cues for the current zoom level and position

Implementation approach:
```javascript
class ZoomPanManager {
  constructor(container, content) {
    this.container = container;
    this.content = content;
    this.scale = 1;
    this.translateX = 0;
    this.translateY = 0;
    this.isDragging = false;
    this.lastMouseX = 0;
    this.lastMouseY = 0;
    
    this.setupEventListeners();
    this.updateTransform();
  }
  
  setupEventListeners() {
    // Zoom with mouse wheel
    this.container.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      this.zoom(delta, e.clientX, e.clientY);
    });
    
    // Pan with mouse drag
    this.container.addEventListener('mousedown', (e) => {
      if (e.target === this.container || e.target.classList.contains('background-grid')) {
        this.startDrag(e.clientX, e.clientY);
      }
    });
    
    document.addEventListener('mousemove', (e) => {
      if (this.isDragging) {
        this.drag(e.clientX, e.clientY);
      }
    });
    
    document.addEventListener('mouseup', () => {
      this.stopDrag();
    });
  }
  
  zoom(delta, mouseX, mouseY) {
    // Calculate mouse position relative to content
    const rect = this.container.getBoundingClientRect();
    const offsetX = mouseX - rect.left;
    const offsetY = mouseY - rect.top;
    
    // Calculate cursor position in content space
    const contentX = (offsetX - this.translateX) / this.scale;
    const contentY = (offsetY - this.translateY) / this.scale;
    
    // Apply zoom
    const newScale = Math.max(0.5, Math.min(3, this.scale + delta));
    
    // Adjust translation to zoom toward cursor position
    this.translateX = offsetX - contentX * newScale;
    this.translateY = offsetY - contentY * newScale;
    this.scale = newScale;
    
    this.updateTransform();
  }
  
  startDrag(mouseX, mouseY) {
    this.isDragging = true;
    this.lastMouseX = mouseX;
    this.lastMouseY = mouseY;
    this.container.style.cursor = 'grabbing';
  }
  
  drag(mouseX, mouseY) {
    if (!this.isDragging) return;
    
    const dx = mouseX - this.lastMouseX;
    const dy = mouseY - this.lastMouseY;
    
    this.translateX += dx;
    this.translateY += dy;
    
    this.lastMouseX = mouseX;
    this.lastMouseY = mouseY;
    
    this.updateTransform();
  }
  
  stopDrag() {
    this.isDragging = false;
    this.container.style.cursor = 'default';
  }
  
  updateTransform() {
    this.content.style.transform = `translate(${this.translateX}px, ${this.translateY}px) scale(${this.scale})`;
    
    // Update grid visibility based on zoom level
    const gridElements = document.querySelectorAll('.grid-line');
    gridElements.forEach(el => {
      if (this.scale < 0.8) {
        el.style.opacity = '0.3';
      } else {
        el.style.opacity = '0.1';
      }
    });
  }
}

// Create background grid
function createBackgroundGrid(container) {
  const grid = document.createElement('div');
  grid.className = 'background-grid';
  
  // Create horizontal lines
  for (let i = 0; i < 50; i++) {
    const line = document.createElement('div');
    line.className = 'grid-line horizontal';
    line.style.top = `${i * 50}px`;
    grid.appendChild(line);
  }
  
  // Create vertical lines
  for (let i = 0; i < 50; i++) {
    const line = document.createElement('div');
    line.className = 'grid-line vertical';
    line.style.left = `${i * 50}px`;
    grid.appendChild(line);
  }
  
  container.appendChild(grid);
}
```

# Test Strategy:
Test zoom and pan functionality across different devices and input methods. Verify that the grid provides proper orientation cues at various zoom levels. Test with large organizational charts to ensure navigation remains intuitive.

# Subtasks:
## 1. Implement Background Grid with Zoom-Responsive Scaling [pending]
### Dependencies: None
### Description: Create a background grid system that provides orientation cues and scales appropriately with zoom level changes
### Details:
Create a function to generate a background grid with horizontal and vertical lines. The grid should have appropriate spacing and styling to serve as a subtle orientation cue. Implement opacity changes based on zoom level to maintain visual clarity. Add CSS classes for styling the grid lines with proper z-index to ensure they stay behind the content.

## 2. Implement Zoom Functionality with Mouse Wheel and Buttons [pending]
### Dependencies: 12.1
### Description: Create smooth zoom in/out functionality that works with both mouse wheel events and UI buttons
### Details:
Implement the zoom method in the ZoomPanManager class that handles mouse wheel events for zooming. Add logic to calculate the zoom point based on cursor position to create a natural zoom-to-cursor effect. Implement zoom buttons in the UI that call the same zoom functionality. Add constraints to prevent excessive zooming in or out beyond usable limits (e.g., 0.5 to 3.0 scale).

## 3. Implement Pan Navigation with Drag Interactions [pending]
### Dependencies: 12.1
### Description: Create intuitive pan navigation that allows users to drag the background to move around the content
### Details:
Implement the startDrag, drag, and stopDrag methods in the ZoomPanManager class. Add event listeners for mousedown, mousemove, and mouseup events to handle the dragging interaction. Update the cursor style during dragging to provide visual feedback. Ensure the pan functionality works correctly with the transformed content and maintains proper positioning.

## 4. Create Mini-Map Navigator for Orientation [pending]
### Dependencies: 12.2, 12.3
### Description: Implement a mini-map in a corner of the view that shows the current viewport position within the larger content area
### Details:
Create a mini-map component that renders a scaled-down version of the entire content. Add a viewport indicator that shows the current visible area. Update the mini-map in real-time as the user zooms and pans. Implement two-way interaction so users can click or drag on the mini-map to navigate to that area in the main view. Position the mini-map in a corner with appropriate styling to be visible but not intrusive.

## 5. Add Visual Cues for Current Zoom Level and Position [pending]
### Dependencies: 12.2, 12.3
### Description: Implement UI indicators that show the current zoom percentage and position to help users maintain orientation
### Details:
Create a zoom level indicator that displays the current scale as a percentage (e.g., "100%"). Add position indicators that show the current viewport coordinates relative to the content. Update these indicators in real-time during zoom and pan operations. Implement the updateTransform method to handle these updates efficiently. Add subtle visual feedback when zoom limits are reached.

